# 从沙箱启动到执行完成的核心步骤（以 cgroupv2 为例）

> 本文档详细介绍了从沙箱启动到在沙箱中完成一次执行的全过程，重点关注基于 cgroupv2 的资源限制机制，展示了沙箱的初始化、配置、执行和资源管理的完整流程。

## 1. 沙箱初始化阶段

> 沙箱初始化阶段负责创建隔离环境、建立通信机制和准备执行环境，是整个沙箱系统的基础。

### 1.1 容器进程创建

1. **宿主进程调用**：通过 `container` 包中的构造函数创建沙箱实例
2. **进程分离**：使用 `clone` 系统调用创建新进程，设置以下隔离标志：
   - `CLONE_NEWNS`：挂载命名空间隔离
   - `CLONE_NEWUTS`：主机名和域名隔离
   - `CLONE_NEWIPC`：IPC 命名空间隔离
   - `CLONE_NEWPID`：进程 ID 命名空间隔离
   - `CLONE_NEWNET`：网络命名空间隔离（可选）
3. **子进程初始化**：子进程执行 `container.Init()` 函数，检查 PID 是否为 1

### 1.2 通信机制建立

1. **Unix Socket 创建**：宿主进程创建 Unix Socket 对，一端保留在宿主进程，另一端传递给容器进程
2. **文件描述符传递**：容器进程通过预定义的文件描述符（fd 3）获取 Socket
3. **通信循环启动**：
   - 容器进程启动 `sendLoop`、`recvLoop` 和 `waitLoop` 三个 goroutine
   - 建立基于命令-响应模式的通信协议

### 1.3 文件系统隔离

1. **根文件系统准备**：
   - 创建临时目录作为新的根文件系统
   - 使用 `pivot_root` 或 `chroot` 切换根目录
2. **关键目录挂载**：
   - 挂载 `/proc`、`/dev`、`/sys` 等必要文件系统
   - 创建临时文件系统（tmpfs）用于 `/tmp` 和工作目录
3. **敏感路径屏蔽**：使用 `maskPath` 函数屏蔽敏感路径，防止访问

## 2. cgroupv2 资源限制配置

> cgroupv2 提供了统一的层级结构来管理和限制进程资源，是沙箱资源隔离的核心机制。

### 2.1 cgroup 控制器初始化

1. **检测 cgroupv2 支持**：
   - 检查系统是否支持 cgroupv2
   - 确认挂载点（通常为 `/sys/fs/cgroup`）
2. **创建 cgroup 子组**：
   - 在 cgroup 层级中创建唯一命名的子组
   - 使用 `V2.New()` 或 `V2.Random()` 方法创建

```go
// 创建随机命名的 cgroup 子组
cg, err := cgroup.NewV2Random("sandbox-*")
```

3. **启用子树控制**：
   - 调用 `enableSubtreeControl()` 方法
   - 写入 `cgroup.subtree_control` 文件，启用所需控制器

### 2.2 资源限制设置

1. **CPU 限制配置**：
   - 设置 CPU 使用配额和周期
   - 调用 `SetCPUBandwidth(quota, period)` 方法

```go
// 限制 CPU 使用为 10% (配额为周期的 10%)
cg.SetCPUBandwidth(10000, 100000) // 微秒单位
```

2. **内存限制配置**：
   - 设置内存使用上限
   - 调用 `SetMemoryLimit(limit)` 方法

```go
// 限制内存使用为 256MB
cg.SetMemoryLimit(256 * 1024 * 1024) // 字节单位
```

3. **进程数量限制**：
   - 设置最大进程数
   - 调用 `SetProcLimit(limit)` 方法

### 2.3 进程关联

1. **获取目标进程 PID**：
   - 从容器进程获取待执行程序的 PID
   - 通过 Unix Socket 传递 PID 信息
2. **添加进程到 cgroup**：
   - 调用 `AddProc(pid)` 方法
   - 将进程 ID 写入 `cgroup.procs` 文件

## 3. 程序执行阶段

> 程序执行阶段负责在隔离环境中启动目标程序，并监控其执行过程。

### 3.1 执行命令准备

1. **参数和环境变量设置**：
   - 构建 `ExecveParam` 结构体
   - 设置命令行参数、环境变量和文件描述符
2. **资源限制准备**：
   - 设置 `rlimit` 限制（如文件大小、CPU 时间等）
   - 配置 `seccomp` 过滤器限制系统调用

### 3.2 命令执行

1. **发送执行命令**：
   - 宿主进程发送 `cmdExecve` 命令
   - 传递执行参数和文件描述符
2. **容器内执行**：
   - 容器进程调用 `handleExecve` 处理执行请求
   - 使用 `forkexec.Runner` 创建子进程
3. **同步执行**：
   - 执行 `syncFunc` 函数，通知宿主进程子进程已创建
   - 宿主进程将子进程添加到 cgroup

### 3.3 执行监控

1. **等待执行完成**：
   - 容器进程注册 `waitPid` 事件
   - 等待子进程退出或超时
2. **资源使用统计**：
   - 收集 `rusage` 信息（用户时间、系统时间、内存使用等）
   - 从 cgroup 文件读取详细资源使用情况

```go
// 读取 CPU 使用情况
cpuUsage, _ := cg.CPUUsage()

// 读取内存使用情况
memUsage, _ := cg.MemoryUsage()
memPeak, _ := cg.MemoryMaxUsage()
```

## 4. 结果处理和清理

> 结果处理和清理阶段负责收集执行结果、释放资源并维护沙箱环境的可重用性。

### 4.1 执行结果收集

1. **状态码解析**：
   - 解析进程退出状态
   - 确定执行结果类型（正常、非零退出、信号终止等）
2. **资源使用汇总**：
   - 汇总 CPU 时间、内存使用等资源统计
   - 生成 `runner.Result` 结构体

```go
result := runner.Result{
    Status:     status,
    ExitStatus: exitStatus,
    Time:       userTime,
    Memory:     userMem,
    SetUpTime:  setupDuration,
    RunningTime: runningDuration,
}
```

### 4.2 资源释放

1. **进程清理**：
   - 确保所有子进程已终止
   - 关闭所有打开的文件描述符
2. **cgroup 清理**：
   - 调用 `cg.Destroy()` 方法
   - 删除创建的 cgroup 子组

### 4.3 沙箱重置（可选）

1. **临时文件清理**：
   - 删除工作目录和临时目录中的文件
   - 调用 `Reset()` 方法清理环境
2. **准备下次执行**：
   - 保持容器进程运行
   - 等待下一次执行请求

## 5. 关键技术和安全机制

> 沙箱实现中采用了多种安全机制，确保隔离性和资源控制的有效性。

### 5.1 多层隔离保障

1. **命名空间隔离**：使用多种 Linux 命名空间实现进程、文件系统等隔离
2. **Seccomp 过滤**：限制可用的系统调用，防止危险操作
3. **Capability 控制**：移除不必要的特权，降低权限

### 5.2 资源精确控制

1. **cgroup 限制**：通过 cgroupv2 实现精确的资源限制和统计
2. **rlimit 限制**：通过进程级别的资源限制提供额外保障
3. **文件系统限制**：通过挂载选项和访问控制限制文件操作

### 5.3 通信安全

1. **Unix Socket 通信**：使用安全的进程间通信机制
2. **文件描述符传递**：安全地传递文件描述符，避免权限提升
3. **同步机制**：使用多种同步原语确保操作顺序和安全性

## 总结

> cgroupv2 沙箱从启动到执行完成涉及多个关键步骤，包括容器初始化、资源限制配置、程序执行和结果处理。通过命名空间隔离、cgroup 资源控制和安全通信机制，实现了高效、安全的代码执行环境。

沙箱的设计充分利用了 Linux 内核提供的隔离和资源控制机制，特别是 cgroupv2 的统一层级结构，使得资源限制更加精确和高效。整个执行流程中，宿主进程和容器进程通过 Unix Socket 保持通信，确保了执行过程的可控性和结果的准确收集。