# fork 实现的分层设计

本文档详细说明了 `fork_linux.go` 和 `fork_child_linux.go` 之间的分层关系和职责划分。

## 1. 整体架构

```mermaid
graph TB
    subgraph "fork_linux.go（高层接口）"
        A[Start] --> B[准备参数]
        B --> C[创建通信管道]
        C --> D[调用 forkAndExecInChild]
        D --> E[同步处理]
        E --> F[错误处理]
    end
    
    subgraph "fork_child_linux.go（底层实现）"
        G[forkAndExecInChild] --> H[fork 进程]
        H --> I[配置命名空间]
        I --> J[设置安全限制]
        J --> K[执行目标程序]
    end
    
    D --> G
    
    style A fill:#f9f,stroke:#333
    style G fill:#f99,stroke:#333
```

## 2. 职责划分

### 2.1 fork_linux.go（高层接口）

1. **参数准备**
   - 程序路径和参数
   - 环境变量
   - 工作目录
   - 主机名和域名
   - 根目录切换参数

2. **进程同步**
   - 创建父子进程通信管道
   - 处理 UID/GID 映射
   - 执行用户定义的同步函数
   - 处理 ptrace 相关同步

3. **错误处理**
   - 参数验证错误
   - 系统调用错误
   - 子进程返回的错误
   - 同步过程中的错误

4. **资源管理**
   - 文件描述符清理
   - 进程清理（避免僵尸进程）
   - 错误状态下的资源释放

### 2.2 fork_child_linux.go（底层实现）

1. **进程创建**
   - 执行 clone 系统调用
   - 设置进程属性
   - 准备执行环境

2. **安全隔离**
   - 命名空间配置
   - 挂载点隔离
   - 用户空间隔离
   - 网络隔离

3. **安全限制**
   - seccomp 规则加载
   - capabilities 控制
   - 资源限制设置
   - ptrace 跟踪设置

4. **环境配置**
   - 文件系统挂载
   - 工作目录设置
   - 主机名配置
   - 文件描述符处理

## 3. 交互流程

```mermaid
sequenceDiagram
    participant P as 父进程(fork_linux.go)
    participant C as 子进程(fork_child_linux.go)
    
    P->>P: 准备参数
    P->>P: 创建通信管道
    P->>C: fork 调用
    
    alt 用户命名空间
        P->>P: 设置 UID/GID 映射
        P->>C: 发送映射完成信号
        C->>C: 等待映射完成
    end
    
    C->>C: 配置隔离环境
    C->>C: 设置安全限制
    
    alt ptrace 启用
        C->>P: 发送 ptrace 就绪信号
        P->>C: 确认附加
    end
    
    C->>C: 加载 seccomp
    C->>C: 执行目标程序
    
    alt 执行失败
        C->>P: 发送错误信息
        P->>P: 清理资源
    end
```

## 4. 错误处理机制

### 4.1 错误传递
```mermaid
graph TD
    A[子进程错误] --> B{错误类型}
    B -->|系统调用错误| C[通过管道发送]
    B -->|执行错误| D[通过管道发送]
    B -->|同步错误| E[通过管道发送]
    
    C --> F[父进程处理]
    D --> F
    E --> F
    
    F --> G[资源清理]
    F --> H[错误转换]
    F --> I[返回调用者]
```

### 4.2 错误分类

1. **参数错误**
   - 无效的参数值
   - 路径转换错误
   - 环境变量错误

2. **系统调用错误**
   - clone 失败
   - execve 失败
   - 权限不足

3. **同步错误**
   - 管道通信失败
   - UID/GID 映射失败
   - ptrace 附加失败

4. **配置错误**
   - 命名空间配置失败
   - 挂载点设置失败
   - seccomp 加载失败

## 5. 安全考虑

1. **进程隔离**
   - 完整的命名空间隔离
   - 文件系统隔离
   - 网络隔离

2. **权限控制**
   - 最小权限原则
   - capabilities 精细控制
   - seccomp 系统调用过滤

3. **资源限制**
   - 内存限制
   - CPU 限制
   - 文件系统限制

4. **错误处理**
   - 完整的错误捕获
   - 资源泄露防护
   - 僵尸进程防护

## 6. 最佳实践

1. **参数验证**
   - 在高层接口进行参数验证
   - 确保所有路径都是有效的
   - 验证环境变量的合法性

2. **错误处理**
   - 始终检查系统调用返回值
   - 正确处理 EINTR 中断
   - 确保资源正确清理

3. **安全配置**
   - 使用最严格的安全策略
   - 仔细审查权限设置
   - 定期更新安全规则

4. **性能优化**
   - 最小化进程间通信
   - 避免不必要的系统调用
   - 优化资源使用
